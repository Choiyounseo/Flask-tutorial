#### Part9 : Pagination

* Submission of Blog Posts

  ```python
  # forms.py
  class PostForm(FlaskForm):
      post = TextAreaField('Say something', validators=[
          DataRequired(), Length(min=1, max=140)])
      submit = SubmitField('Submit')
  ```

  ```html
  // index.html
  {% extends "base.html" %}
  
  {% block content %}
      <h1>Hi, {{ current_user.username }}!</h1>
      <form action="" method="post">
          {{ form.hidden_tag() }}
          <p>
              {{ form.post.label }}<br>
              {{ form.post(cols=32, rows=4) }}<br>
              {% for error in form.post.errors %}
              <span style="color: red;">[{{ error }}]</span>
              {% endfor %}
          </p>
          <p>{{ form.submit() }}</p>
      </form>
      {% for post in posts %}
      <p>
      {{ post.author.username }} says: <b>{{ post.body }}</b>
      </p>
      {% endfor %}
  {% endblock %}
  ```

  ```python
  # routes.py
  from app.forms import PostForm
  from app.models import Post
  
  @app.route('/', methods=['GET', 'POST'])
  @app.route('/index', methods=['GET', 'POST'])
  @login_required
  def index():
      form = PostForm()
      if form.validate_on_submit():
          post = Post(body=form.post.data, author=current_user)
          db.session.add(post)
          db.session.commit()
          flash('Your post is now live!')
          return redirect(url_for('index'))
      posts = [
          {
              'author': {'username': 'John'},
              'body': 'Beautiful day in Portland!'
          },
          {
              'author': {'username': 'Susan'},
              'body': 'The Avengers movie was so cool!'
          }
      ]
      return render_template("index.html", title='Home Page', form=form,
                             posts=posts)
  ```

  * `redirect`를 하는 이유 : `Post/Redirect/Get` pattern
    * avoids inserting duplicate posts when user inadvertently refreshes the page after submitting a web form
    * It is a standard practice to respond to a `POST` request generated by a web form submission with a redirect. This helps mitigate an annoyance with how the refresh command is implemented in web browsers. All the web browser does when you hit the refresh key is to re-issue the last request. If a `POST` request with a form submission returns a regular response, then a refresh will re-submit the form. Because this is unexpected, the browser is going to ask the user to confirm the duplicate submission, but most users will not understand what the browser is asking them. But if a `POST` request is answered with a redirect, the browser is now instructed to send a `GET` request to grab the page indicated in the redirect, so now the last request is not a `POST` request anymore, and the refresh command works in a more predictable way.



* Displaying Blog Posts

  ```python
  posts = current_user.followed_posts().all()
  ```



* Make Easier to Find Users to Follow

  ```python
  # routes.py
  @app.route('/explore')
  @login_required
  def explore():
      posts = Post.query.order_by(Post.timestamp.desc()).all()
      return render_template('index.html', title='Explore', posts=posts)
  ```

  * `index.html`에 `{% if form %}`, `{% endif %}` 추가

  

  ```html
  // _post.html
  <table>
      <tr valign="top">
          <td><img src="{{ post.author.avatar(36) }}"></td>
          <td>
              <a href="{{ url_for('user', username=post.author.username) }}">
                  {{ post.author.username }}
              </a>
              says:<br>{{ post.body }}
          </td>
      </tr>
  </table>
  ```

  * show username of the blog post author as a link
  * `post.author.username`!



* Pagination of Blog Posts

  * Flask-SQLAlchemy supports pagination, **`paginate()` query**
    * *paginate* the post list

  ```
  >>> user.followed_posts().paginate(1, 20, False).items
  ```

  * `paginate()` : 3 arguments
    * the page number, starting from 1
    * the number of items per page
    * an error flag. If `True`, when an out of range page is requested a 404 error will be automatically returned to the client. If `False`, an empty list will be returned for out of range pages.
  * Return value: `Pagination` object=> `items` 를 이용해 object가 가지고 있는 list of items 가져오기 가능

  

  ```python
  # config.py
  class Config(object):
      # ...
      POSTS_PER_PAGE = 3
  ```

  * Determines how many items will be displayed per page
  * also need to decide how the page number is going to be incorporated into application URLs. A fairly common way is to use a *query string* argument to specify an optional page number, **defaulting to page 1 if it is not given**. Here are some example URLs that show how I'm going to implement this:
    * Page 1, implicit: *http://localhost:5000/index*
    * Page 1, explicit: *http://localhost:5000/index?page=1*
    * Page 3: *http://localhost:5000/index?page=3*
  * To access arguments given in the query string, I can use the Flask's **`request.args`** object. 

  

  ```python
  # routes.py
  @app.route('/', methods=['GET', 'POST'])
  @app.route('/index', methods=['GET', 'POST'])
  @login_required
  def index():
      # ...
      page = request.args.get('page', 1, type=int)
      posts = current_user.followed_posts().paginate(
          page, app.config['POSTS_PER_PAGE'], False)
      return render_template('index.html', title='Home', form=form,
                             posts=posts.items)
  
  @app.route('/explore')
  @login_required
  def explore():
      page = request.args.get('page', 1, type=int)
      posts = Post.query.order_by(Post.timestamp.desc()).paginate(
          page, app.config['POSTS_PER_PAGE'], False)
      return render_template("index.html", title='Explore', posts=posts.items)
  ```

  * `page` : 몇 번째 페이지인지 url의 query를 이용해 알아냄
  * `app.config['POST_PER_PAGE']` = 3으로 현재 정의되어 있음( 한페이지 당 3개의 post가 보임)
  * 현재 `http://localhost:5000/explore?page=2 ` 식으로 페이지 두번째 글들 보기 가능



* Page Navigation

  * add links at the bottom of the blog post list that allow users to navigate to the next / previous pages
  * `items` 이외에 `Pagination` class에 사용할수 있는 attributes들
    * `has_next`: True if there is at least one more page after the current one
    * `has_prev`: True if there is at least one more page before the current one
    * `next_num`: page number for the next page
    * `prev_num`: page number for the previous page

  

  ```python
  # routes.py
  @app.route('/', methods=['GET', 'POST'])
  @app.route('/index', methods=['GET', 'POST'])
  @login_required
  def index():
      # ...
      page = request.args.get('page', 1, type=int)
      posts = current_user.followed_posts().paginate(
          page, app.config['POSTS_PER_PAGE'], False)
      next_url = url_for('index', page=posts.next_num) \
          if posts.has_next else None
      prev_url = url_for('index', page=posts.prev_num) \
          if posts.has_prev else None
      return render_template('index.html', title='Home', form=form,
                             posts=posts.items, next_url=next_url,
                             prev_url=prev_url)
  
   @app.route('/explore')
   @login_required
   def explore():
      page = request.args.get('page', 1, type=int)
      posts = Post.query.order_by(Post.timestamp.desc()).paginate(
          page, app.config['POSTS_PER_PAGE'], False)
      next_url = url_for('explore', page=posts.next_num) \
          if posts.has_next else None
      prev_url = url_for('explore', page=posts.prev_num) \
          if posts.has_prev else None
      return render_template("index.html", title='Explore', posts=posts.items,
                            next_url=next_url, prev_url=prev_url)
  
  ```

  * `url_for()` function : can add any keyword arguments to it
    * if the names of those arguments are not referenced in the URL directly, Flask will include them in the URL as query arguments

  ```html
  // index.html
  {% if prev_url %}
  <a href="{{ prev_url }}">Newer posts</a>
  {% endif %}
  {% if next_url %}
  <a href="{{ next_url }}">Older posts</a>
  {% endif %}
  ```



* Pagination in the User Profile Page

  ```python
  #routes.py
  @app.route('/user/<username>')
  @login_required
  def user(username):
      user = User.query.filter_by(username=username).first_or_404()
      page = request.args.get('page', 1, type=int)
      posts = user.posts.order_by(Post.timestamp.desc()).paginate(
          page, app.config['POSTS_PER_PAGE'], False)
      next_url = url_for('user', username=user.username, page=posts.next_num) \
          if posts.has_next else None
      prev_url = url_for('user', username=user.username, page=posts.prev_num) \
          if posts.has_prev else None
      return render_template('user.html', user=user, posts=posts.items,
                             next_url=next_url, prev_url=prev_url)
  ```

  * `/login` route와 차이점은 Post = user.posts인점 (이전에는 current_user.followed_posts())를 사용
  * `/user/<username>`의 경우, username != current_user여도 상관이 없어야 하기 때문에 username을 통해 user를 찾아서 사용

  ```html
  {% for post in posts %}
  {% include '_post.html' %}
  {% endfor %}
  {% if prev_url %}
  <a href="{{ prev_url }}">Newer posts</a>
  {% endif %}
  {% if next_url %}
  <a href="{{ next_url }}">Older posts</a>
  {% endif %}
  ```

